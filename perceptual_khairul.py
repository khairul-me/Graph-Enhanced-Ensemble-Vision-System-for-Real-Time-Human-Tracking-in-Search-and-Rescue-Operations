# -*- coding: utf-8 -*-
"""perceptual_Khairul.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tnZ0LOSg51XVeycjPVaB6QA_dIrc9x4u
"""

# Cell 1: Imports and Setup
# =============================================================================
import tensorflow as tf
from tensorflow.keras import layers, models
import numpy as np
import matplotlib.pyplot as plt

print("TensorFlow Version:", tf.__version__)

# Cell 2: The Encoder Model
# =============================================================================
def build_encoder(num_keypoints=4, rotation_dim=4):
    """Builds the CNN-based encoder model (`Ï†`)."""
    inputs = layers.Input(shape=(None, None, 3), name='encoder_input_image')
    x = layers.Conv2D(32, 5, strides=2, padding='same', activation='relu')(inputs)
    x = layers.Conv2D(64, 5, strides=2, padding='same', activation='relu')(x)
    static_features = layers.Conv2D(128, 5, strides=2, padding='same', activation='relu')(x)
    heatmaps = layers.Conv2D(num_keypoints, 1, name='heatmaps')(static_features)
    num_coeffs = num_keypoints * (1 + rotation_dim)
    raw_coeffs_map = layers.Conv2D(num_coeffs, 1, name='pose_coeffs')(static_features)
    return models.Model(inputs=inputs, outputs=[heatmaps, raw_coeffs_map, static_features], name='Encoder')

# Cell 3: The Spatial Soft-Argmax Function
# =============================================================================
def spatial_soft_argmax(heatmaps):
    """Converts heatmaps to (x, y) coordinates using a differentiable spatial softmax."""
    B, H, W, N = tf.shape(heatmaps)[0], tf.shape(heatmaps)[1], tf.shape(heatmaps)[2], tf.shape(heatmaps)[3]
    flat_heatmaps = tf.reshape(heatmaps, [B, -1, N])
    softmax_probs = tf.nn.softmax(flat_heatmaps, axis=1)
    softmax_heatmaps = tf.reshape(softmax_probs, [B, H, W, N])
    x_coords, y_coords = tf.cast(tf.range(W), tf.float32), tf.cast(tf.range(H), tf.float32)
    xx_grid, yy_grid = tf.meshgrid(x_coords, y_coords)
    xx_grid, yy_grid = tf.reshape(xx_grid, [1, H, W, 1]), tf.reshape(yy_grid, [1, H, W, 1])
    x_keypoints = tf.reduce_sum(softmax_heatmaps * xx_grid, axis=[1, 2])
    y_keypoints = tf.reduce_sum(softmax_heatmaps * yy_grid, axis=[1, 2])
    keypoints = tf.stack([x_keypoints, y_keypoints], axis=-1)
    return keypoints, softmax_heatmaps

# Cell 4: The Gaussian Map Generator (Revised for Clarity)
# =============================================================================
def generate_rotated_gaussian_maps(keypoints, scale_factors, rotation_coeffs, height, width, kernels, sigma=5.0):
    """
    Generates rotated and scaled Gaussian-like maps from pose vectors.

    REVISED: This version returns a list of the C rotated map components,
    which is a cleaner and less error-prone data structure than a single
    large concatenated tensor. Each element in the list has shape [B, N, H, W].
    """
    B, N, C = tf.shape(keypoints)[0], tf.shape(keypoints)[1], tf.shape(rotation_coeffs)[2]
    y_grid, x_grid = tf.cast(tf.range(height), tf.float32), tf.cast(tf.range(width), tf.float32)
    yy, xx = tf.meshgrid(y_grid, x_grid, indexing='ij')
    yy, xx = tf.reshape(yy, [1, 1, height, width]), tf.reshape(xx, [1, 1, height, width])

    mu_x = tf.expand_dims(tf.expand_dims(keypoints[..., 0], -1), -1)
    mu_y = tf.expand_dims(tf.expand_dims(keypoints[..., 1], -1), -1)
    scale = tf.expand_dims(tf.expand_dims(scale_factors, -1), -1)

    # Eq. 4: Create the base isotropic Gaussian map.
    isotropic_gaussian_maps = scale * tf.exp(-((xx - mu_x)**2 + (yy - mu_y)**2) / (2.0 * sigma**2))

    # Eq. 5: Apply rotational kernels and weight by coefficients.
    g_maps_reshaped = tf.reshape(isotropic_gaussian_maps, [B * N, height, width, 1])

    rotated_map_components = []
    for i in range(C):
        # Convolve with the i-th kernel.
        conv_map = tf.nn.conv2d(g_maps_reshaped, kernels[i], strides=1, padding='SAME')
        conv_map = tf.reshape(conv_map, [B, N, height, width])
        # Weight the result by the i-th rotation coefficient.
        r_i = tf.expand_dims(tf.expand_dims(rotation_coeffs[:, :, i], -1), -1)
        weighted_map = conv_map * r_i
        rotated_map_components.append(weighted_map)

    # Return the un-concatenated list of components and the base maps.
    return rotated_map_components, isotropic_gaussian_maps

# Cell 5: The Visualization Function (Revised for Clarity)
# =============================================================================
def visualize_full_process(static_features, softmax_heatmaps, keypoints, scale_factors, rotation_coeffs, isotropic_gaussian_maps, rotated_map_components, img_index=0, num_keypoints_to_show=3):
    """A comprehensive visualization function with simplified, robust logic."""
    print("\n\n" + "="*80)
    print(" VISUALIZATION: DECODING THE PERCEPTUAL MODULE'S OUTPUT (Final Version)")
    print("="*80 + "\n")

    # Extract data for the chosen image in the batch
    static_features_np = static_features.numpy()[img_index]
    softmax_heatmaps_np = softmax_heatmaps.numpy()[img_index]
    keypoints_np = keypoints.numpy()[img_index]
    scale_factors_np = scale_factors.numpy()[img_index]
    rotation_coeffs_np = rotation_coeffs.numpy()[img_index]
    isotropic_gaussian_maps_np = isotropic_gaussian_maps.numpy()[img_index]

    # `rotated_map_components` is a list of tensors.
    # We extract the numpy arrays for the chosen image from each tensor in the list.
    rotated_maps_np_list = [comp.numpy()[img_index] for comp in rotated_map_components]

    N = softmax_heatmaps.shape[-1]
    num_keypoints_to_show = min(num_keypoints_to_show, N)

    for kp_index in range(num_keypoints_to_show):
        fig, axs = plt.subplots(1, 4, figsize=(22, 5))
        fig.suptitle(f"--- Keypoint #{kp_index+1} Analysis ---", fontsize=16, y=1.05)

        kp_x, kp_y = keypoints_np[kp_index, 0], keypoints_np[kp_index, 1]
        scale = scale_factors_np[kp_index]
        rot_coeffs_str = ", ".join([f"{c:.2f}" for c in rotation_coeffs_np[kp_index]])

        # Panels 1, 2, 3 remain the same as they were correct.
        axs[0].imshow(np.mean(static_features_np, axis=-1), cmap='gray')
        axs[0].set_title(f"1. Static Features & Location")
        axs[0].scatter(kp_x, kp_y, c='red', s=50, marker='x', label=f'({kp_x:.1f}, {kp_y:.1f})')
        axs[0].legend()
        axs[0].set_xlabel(f'Keypoint found in this region of the features.')

        im1 = axs[1].imshow(softmax_heatmaps_np[:, :, kp_index], cmap='viridis')
        axs[1].set_title(f"2. Softmax Heatmap (Attention)")
        axs[1].set_xlabel('Normalized map showing object certainty.')
        fig.colorbar(im1, ax=axs[1], fraction=0.046, pad=0.04)

        im2 = axs[2].imshow(isotropic_gaussian_maps_np[kp_index], cmap='hot')
        axs[2].set_title(f"3. Isotropic Gaussian Map")
        axs[2].set_xlabel(f'Generated from (x,y) & scale={scale:.2f}')
        fig.colorbar(im2, ax=axs[2], fraction=0.046, pad=0.04)

        # **** THE ROBUST FIX IS HERE ****
        # Get all C components for the current keypoint.
        keypoint_components = [rot_map[kp_index] for rot_map in rotated_maps_np_list]
        # Sum them to create the final composed map for visualization.
        composed_map = np.sum(keypoint_components, axis=0)

        im3 = axs[3].imshow(composed_map, cmap='coolwarm')
        axs[3].set_title("4. Final Composed Pose Map")
        axs[3].set_xlabel(f'Rotated using coeffs: [{rot_coeffs_str}]')
        fig.colorbar(im3, ax=axs[3], fraction=0.046, pad=0.04)

        plt.tight_layout()
        plt.show()

# Cell 6: The Demonstration Runner
# =============================================================================
def run_demo():
    """Runs the full, corrected, and explanatory forward pass."""
    # Hyperparameters
    B, IMG_SIZE, NUM_KEYPOINTS, ROTATION_DIM = 1, 128, 4, 4

    print("="*80)
    print(" DEMO: FORWARD PASS OF THE PERCEPTUAL MODULE (Final Corrected Version)")
    print("="*80)

    # Steps 1-4: Get all the necessary Tensors from the encoder
    img = tf.random.uniform([B, IMG_SIZE, IMG_SIZE, 3])
    encoder = build_encoder(num_keypoints=NUM_KEYPOINTS, rotation_dim=ROTATION_DIM)
    heatmaps, raw_coeffs_map, static_features = encoder(img)
    keypoints, softmax_heatmaps = spatial_soft_argmax(heatmaps)

    H, W = raw_coeffs_map.shape[1], raw_coeffs_map.shape[2]
    reshaped_coeffs = tf.reshape(raw_coeffs_map, [B, H, W, NUM_KEYPOINTS, 1 + ROTATION_DIM])
    attention_weights = tf.expand_dims(softmax_heatmaps, axis=-1)
    weighted_coeffs = tf.reduce_sum(attention_weights * reshaped_coeffs, axis=[1, 2])
    scale_factors = weighted_coeffs[..., 0]
    rotation_coeffs = weighted_coeffs[..., 1:]

    # Step 5: Define learnable rotation kernels
    kernels = [tf.Variable(tf.random.normal([5, 5, 1, 1]), trainable=True) for _ in range(ROTATION_DIM)]

    # Step 6: Generate the maps using the revised function
    print(f"\n--- [Step 6] Pose Map Generation (Eq. 4 & 5) ---")
    rotated_map_components, isotropic_gaussian_maps = generate_rotated_gaussian_maps(
        keypoints, scale_factors, rotation_coeffs, height=H, width=W, kernels=kernels
    )
    print(f"  - Isotropic (base) Gaussian maps Shape: {isotropic_gaussian_maps.shape}")
    print(f"  - Returned a list of {len(rotated_map_components)} rotated map components.")
    print(f"  - Shape of each component in the list: {rotated_map_components[0].shape}")


    # Step 7: Visualize with the robust visualization function
    visualize_full_process(
        static_features, softmax_heatmaps, keypoints, scale_factors,
        rotation_coeffs, isotropic_gaussian_maps, rotated_map_components,
        img_index=0, num_keypoints_to_show=3
    )

# Run the final, correct demo
run_demo()